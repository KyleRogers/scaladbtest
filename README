== ScalaDBTest

Goals:

- Create a new, light-weight database population framework for scala to replace
  DBUnit completely.

- Get it to work for mysql and hsqldb first, which are the two databases which
  are the most interest to me. Others can contribute implementations for the
  other databases management systems.

- Requires simple formats to build and load test data. Unfortunately with
  DBUnit, the simplest formats are deprecated. They have too many to select
  from, which makes it confusing. Some require xml schemas, which violates the
  DRY principle and is rather bloated.

  Solutions:
  - A simple markup language can be one possibility, something akin to yaml in
    Rails.
  - A Scala DSL, which could be expressive as well as type-checked.

- Must be really easy to setup, such as having a collection of traits to mix
  into various test frameworks. Make it work out of the box as much as possible,
  preferably with just a Connection object and a reference to either a markup
  language file or a DSL Class. There can be ways to specify how the data is
  loaded and cleaned, but in my experience, every project tends to do the same
  pattern so why not give good defaults.

- DBunit populates rows in a different order than how you write them in the XML
  file. A better method is populate the data based on the order its written so
  that foreign key constraints won't cause problems.

- Should automatically disable foreign key constraints when the first test runs.
  This requires knowledge for each specific database. Since it is common for
  data to have circular references, it is annoying for the user to have to
  disable it manually, especially for databases like hsqldb where the user may
  not be familiar with how to do it. This wastes time and detracts from writing
  tests. This should be done by the framework automatically (a sensible default)
  with an option to disable it.

- Offer a way to use symbols/labels to identity individual records rather than
  use ids. We can get the hash code and make that a unique identifier instead.
  The rational is that when data gets large, it is difficult to keep track of
  all the ids and map their relationships, especially if you haven't worked on
  a project in a long time. Labels are better than arbitrary numbers.

- Make it as fast as possible. This means placing them all in a transaction and
  using batch inserts and flushing them to the database every 20 or so inserts.

- Gives records the ability to inherit default values for a given table, so
  that it's easier to create relevant test data. It also reduces typing and
  cognitive load since you don't have to specify every column.

- Allow for an expression language, to point to other values such as labels to
  avoid duplication as well as a way to create dates easily (this often wastes
  a lot of time as you may not care about the date).

- Allow for the ability to express "NULL" very easily, as this is very common
  to do. DBUnit has to be configured to translate strings like [NULL], which is
  a pain to setup initially. We want to make this very easy to get started for
  users.

- Allow for flexibility in the columns that are specified. With DBUnit, the
  first record must contain all the columns, even when they are just null
  values. This turns out to be a royal pain. Insert statements will be
  individually crafted per record. This should make polymorphic objects (both
  single-table and multi-table) much easier to build test-data for.

- Provide support for nosql databases using the same dsls